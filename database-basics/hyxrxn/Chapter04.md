## 뷰
- 하나 이상의 테이블을 합하여 만든 가상의 테이블
- 실제 데이터베이스에 열을 추가하면 프로그램 수정, 저장 용량 증가 등의 문제 발생
- 그래서 가상의 테이블인 뷰를 사용
- 뷰 생성 시 사용한 SELECT 문의 정의를 저장, 이를 이용해 결과 반환

### 장점
- 편리성 및 재사용성: 미리 정의된 뷰를 사용할 수 있음
- 보안성: 각 사용자별로 데이터를 선별해 보여줄 수 있음
- 독립성: 논리 데이터베이스의 원본 테이블의 구조가 변해도 응용 프로그램에 영향을 주지 않음

### 생성
```sql
CREATE VIEW 뷰이름 [(얼이름[,...n])]
AS SELECT 문
```

### 수정
```sql
CREATE OR REPLACE VIEW 뷰이름 [(얼이름[,...n])]
AS SELECT 문
```

### 삭제
```sql
DROP VIEW 뷰이름 [(얼이름[,...n])]
```

## 인덱스
- 자료를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조
- 튜플의 키 값의 물리적 위치를 기록

### B-tree
- 일반적인 RDBMS의 인덱스 구조
- 루트 노드, 내부 노드, 리프 노드로 구성
- 균형 트리
- 각 노드는 키 값과 포인터로 구성
- 키 값은 오름차순, 좌우의 포인터는 각각 키 값보다 작은 값과 큰 값을 가진 다음 노드를 가리킴

### 특징
- 한 개 이상의 속성을 이용해 생성
- 빠른 검색 / 효율적인 레코드 접근 가능
- 테이블보다 작은 공간 차지
- 테이블의 부분집합
- 일반적으로 B-tree 구조
- 데이터의 수정, 삭제 등 변경 발생 시 재구성 필요

### MySQL 인덱스
- 클러스터 인덱스
  - 인덱스의 리프 노드들이 정렬된 상태로 저장된 테이블 자체
  - 테이블당 하나만 생성 가능
  - 동등 및 범위 검색 모두에 유리
  - 페이지가 단순해져 인덱스 저장에 사용하는 공간 작음
  - PK 생성 시 자동 생성
- 보조 인덱스
  - 클러스터 인덱스가 아닌 모든 인덱스
  - 보조 인덱스의 각 레코드는 보조 인덱스 속성과 기본키 속성 값을 갖고있음
  - 보조 인덱스를 검색해 기본키 속성 값을 찾은 다음 클러스터 인덱스에서 해당 레코드 찾음

### 생성
- 선택도(selectivity): 1/서로 다른 값의 개수
- 데이터의 양이 적거나 선택도가 높을 경우 인덱스가 없는 게 더 빠를 수 있음
- 고려 사항
  - WHERE 절에 자주 사용되어야 함
  - JOIN에 자주 사용되어야 함
  - 속성이 가공되는 경우 사용하지 않음
  - 선택도가 낮을 때 유리
```sql
CREATE [UNIQUE] INDEX [인덱스이름]
ON 테이블이름 (컬럼 [ASC | DESC] [{, 컬럼 [ASC | DESC]} ...])[;]
```

### 재구성
```sql
ANALYZE TABLE 테이블이름;
```

### 삭제
```sql
DROP INDEX 인덱스이름
```

## 정규화
### 함수 종속성
- A -> B
  - 어떤 속성 A의 값을 알면 다른 속성 B의 값이 유일하게 정해지는 관계
  - 속성 A는 속성 B를 결정(determine)
  - 속성 B는 속성 A에 종속(dependent)
  - A는 B의 결정자
- 현재 데이터가 아닌 속성의 의미로 판단
- 완전 함수 종속
  - A -> B 일 때, B가 A의 속성 전체에 함수 종속하고 부분 집합 속성에 함수 종속하지 않을 경우

### 함수 종속성 다이어그램
- 릴레이션의 속성은 직사각형
- 속성 간의 함수 종속성은 화살표
- 복합 속성은 직사각형으로 묶어서

### 함수 종속성 규칙
- 부분집합 규칙(subset)
  - if X ⊆ Y, then X -> Y
- 증가 규칙(augmentation)
  - if X -> Y, then XZ -> YZ
- 이행 규칙(transitivity)
  - if X -> Y and Y -> Z, then X -> Z
- 결합 규칙(union)
  - if X -> Y and X -> Z, then X -> YZ
- 분해 규칙(decomposition)
  - if X -> YZ, then X -> Y and X -> Z
- 유사이행 규칙(pseudotransitivity)
  - if X -> Y and WY -> Z, then WX -> Z

### 이상현상
- 데이터베이스 설계가 잘못되었을 경우 발생
- 기본키가 아니면서 결정자인 속성이 있을 때 발생
- 삭제이상: 삭제 시 연쇄삭제 현상 발생
- 삽입이상: 삽입 시 부득이하게 NULL값 입력
- 수정이상: 수정 시 데이터 일관성 훼손

### 정규화(normalization)
- 릴레이션을 분해하여 이상현상을 없애는 과정

### 정규형
- 높을수록 이상현상 감소
- 제 1정규형
  - 릴레이션의 속성 값이 원자값
- 제 2정규형
  - 기본키가 아닌 속성이 기본키에 완전 함수 종속
- 제 3정규형
  - 기본키가 아닌 속성이 기본키에 비이행적(non-transitive)으로 종속
- BCNF(Boyce Codd Normal Form)
  - X -> Y 가 성립할 때, 모든 결정자 X가 후보키
- 제 4정규형
  - 다치종속성(multivalued dependency)을 가진 릴레이션 관련
- 제 5정규형/프로젝트-조인 정규형(PJ/NF)
  - 조인종속성(join dependency)을 가진 릴레이션 관련

### 무손실 분해
- 분해된 릴레이션에 공통 속성을 한 개 이상 두어야 함
- R1 ⋈ R2 = R 이 되는 공통 속성

## 트랜잭션
- 데이터를 다루는 논리적인 작업의 단위
- 장애 발생 시 데이터를 복구하는 작업의 단위가 됨
- 여러 작업이 동시에 같은 데이터를 다룰 때 이를 분리하는 단위가 됨
- 전체가 수행되거나 전혀 수행되지 않아야 함
- 시작 -> 수행 -> 부분완료 -> 버퍼내용 기록 -> 완료
- 예시
  - A 계좌의 값 하드디스크에서 주기억장치 버퍼로 읽어옴
  - B 계좌의 값 하드디스크에서 주기억장치 버퍼로 읽어옴
  - A 계좌에서 1,000원을 인출한 값 저장
  - B 계좌에서 1,000원을 입급한 값 저장
  - 부분완료
  - A 계좌의 값을 주기억장치 버퍼에서 하드디스크에 기록
  - B 계좌의 값을 주기억장치 버퍼에서 하드디스크에 기록
  - 완료

### 트랜잭션 제어 명령어(TCL, Transaction Control Language)
- SET TRANSACTION
  - 트랜잭션 시작
- COMMIT
  - 트랜잭션 종료
- SAVE <identifier>
  - <savepoint> 생성
- ROLLBACK [TO <savepoint>]
  - 트랜잭션을 전체 혹은 <savepoint>까지 무효화

### ACID 성질
- 원자성(Atomicity)
  - 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 함
- 일관성(Consistency)
  - 트랜잭션을 수행하기 전이나 수행한 후나 DB는 항상 일관된 상태를 유지해야 함
  - 무결성 제약조건 활용
- 고립성(Isolation)
  - 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 함
  - 동시성 제어(concurrency control) 또는 트랜잭션 상호 간섭 완화 필요
- 지속성(Durability)
  - 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 함
  - 회복 관리자 프로그램 이용

## 락
- 두 트랜잭션이 모두 쓰기 작업을 하는 경우 갱신손실문제 발생할 수 있음
- 트랜잭션이 데이터를 사용하는지 여부를 알 수 있어야 함
- 락을 사용해 자신이 데이터를 수정 중이라는 것을 알림

### 유형
- 공유락(LS, shared lock)
  - 읽기를 할 때 사용
- 배타락(LX, exclusive lock)
  - 읽기/쓰기를 할 때 사용

### 규칙
- 데이터에 락이 걸려있지 않으면 트랜잭션은 데이터에 락을 걸 수 있음
- 읽기만 할 경우 LS 요청, 읽기나 쓰기를 할 경우 LX 요청
- 다른 트랜잭션이 LS를 걸어두면 LS는 혀용, LX는 비허용
- 다른 트랜잭션이 LX를 걸어두면 LS, LX 모두 비허용
- 트랜잭션이 락을 허용받지 못하면 대기

### 2단계 락킹
- 확장단계(Growing phase, Expanding phase)
  - 트랜잭션이 필요한 락을 획득하는 단계
  - 이미 획득한 락 해제하지 않음
- 수축단계(Shrinking phase)
  - 트랜잭션이 락을 해제하는 단계
  - 새로운 락 획득하지 않음

### 데드락
- 두 트랜잭션이 각각 자신의 락을 가지고 상대방의 락을 요청해 무한 대기 상태에 빠진 것
- 대기 그래프(wait-for graph)에서 에서 사이클이 존재하면 데드락 발생한 것
- 일반적으로 두 작업 중 하나를 강제로 중지시킴

## 트랜잭션 고립 수준
### 오손 읽기(dirty read)
- 쓰기 작업을 하던 도중 중간 데이터를 읽어서 발생
- 쓰기 작업을 하던 트랜잭션이 작업을 철회할 경우 무효가 된 값을 읽게 됨

### 반복불가능 읽기(non-repeatable read)
- 데이터를 두 번 읽을 때 그 사이에 갱신 작업을 해 발생
- 이전의 결과와 다른 값을 읽게 됨

### 유령데이터 읽기(phantom read)
- 데이터를 두 번 읽을 때 그 사이에 삽입 작업을 해 발생
- 이전에 없던 데이터가 나타나게 됨

### 고립 수준 명령어(transaction isolation level instruction)
- 락보다 완화된 방법으로 문제를 해결하기 위해 사용
- SQL 표준 정의
  - READ UNCOMMITTED
  - READ COMMITTED
  - REPEATABLE READ
  - SERIALIZABLE

### Level = 0 (READ UNCOMMITTED)
- SELECT문에는 공유락 걸지 않음
- UPDATE문에는 배타락 설정 (갱신손실 때문)
- 다른 트랜잭션의 공유락과 배타락이 걸린 데이터를 읽음

### Level = 1 (READ COMMITTED)
- SELECT문에는 공유락 걸고 작업 끝나면 바로 해지
- 다른 트랜잭션의 배타락은 읽지 못함
- 오손 읽기 해결

### Level - 2 (REPEATABLE READ)
- SELECT문에는 공유락 걸고 트랜잭션 끝날 때까지 유지
- 반복불가능 읽기 해결

### LEVEL - 3 (SERIALIZABLE)
- 인덱스에 공유락 설정해 다른 트랜잭션의 INSERT문 금지
- 유령데이터 읽기 해결

## 회복
- DB에 장애가 발생했을 때 일관성 있는 상태로 되돌리는 기능
- 시스템 충돌, 미디어 장애, 응용 소프트웨어 오류에 중점을 둠
- 로그의 내용을 참조해 변경 내용을 모두 반영하거나 아예 반영하지 않음

### 로그 파일
- 트랜잭션이 반영한 모든 데이터의 변경사항을 DB에 기록하기 전에 미리 기록해두는 별도의 DB
- 전원과 관계없이 기록이 남음
- 구조: <트랜잭션번호, 로그 타입, 데이터 항목 이름, 수정 전 값, 수정 후 값>

### 재실행(REDO)
- 로그 파일에 트랜잭션의 시작과 종료가 있는 경우
- 완료되었기 때문에 로그를 보며 트랜잭션이 변경한 내용 DB에 다시 기록

### 취소(UNDO)
- 로그 파일에 트랜잭션의 시작만 있는 경우
- 오나료되지 못했기 때문에 트랜잭션이 변경한 내용을 DB에서 원상복구

### 체크포인트(checkpoint)
- 몇 십 분 단위로 DB와 로그 파일을 동기화하고 동기화한 시점을 로그 파일에 기록하는 방법 혹은 그 시점
- 로그를 이용하면 장애 발생 시 어느 시점까지 되돌아가야 하는지 알 수 없기 때문
- 과정
  - 주기억장치의 로그 레코드를 모두 하드디스크의 로그 파일에 저장
  - 버퍼에 있는 변경된 내용을 하드디스크의 DB에 저장
  - 체크포인트를 로그 파일에 표시
- 회복 방법
  - 체크포인트 이전에 COMMIT 기록 존재: 아무 작업 필요 없음
  - 체크포인트 이후에 COMMIT 기록 존재: REDO 진행
  - 체크포인트 이후에도 COMMIT 기록 미존재: UNDO 진행
