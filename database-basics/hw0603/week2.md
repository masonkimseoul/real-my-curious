# 정규화, 트랜잭션, 락

### 이상 현상
잘못 설계된 테이블에서 데이터 조작 시 발생하는 의도하지 않은 현상.
(읽기를 제외한) C, U, D 과정에서 이상현상이 일어남.
테이블에 튜플을 삽입 시 부득이하게 `NULL` 값이 삽입될 수도 있고, 삭제 시 원하지 않는 데이터가 같이 삭제되거나, 수정 시 데이터의 일관성이 훼손될 수 있다.

### 삽입 이상
튜플 삽입 시 특정 속성에 해당하는 값이 없어 `NULL` 을 삽입해야 하는 현상
### 삭제 이상
튜플 삭제 시 같이 저장된 다른 정보까지 연쇄 삭제되는 현상
### 수정 이상
튜플 수정 시 중복된 데이터의 일부만 수정되어 데이터의 불일치 문제가 발생하는 현상

### 데이터베이스 정규화란?
테이블 이상현상이 발생하는 이유는 보통 두 가지 이상의 정보가 ==한== 릴레이션에 저장되어 있기 때문.
- 따라서 이상현상은 릴레이션을 분해하여 제거해야 함
- 분해된 릴레이션에 이상현상이 남아 있다면 이상현상이 없어질 때까지 분해
- 이상현상이 발생하는 릴레이션을 분해하여 이상현상을 없애는 과정이 `정규화`
<u>결국, 정규화는 DB에 저장되는 데이터의 중복을 최소화하고, 일관성을 유지하기 위해 수행한다.</u>

제 1정규화는 모든 칼럼의 데이터를 원자값으로바꾸는 것

제 2정규화는 완전 함수 종속이 되도록 하는 것. 이때 완전 함수 종속이란 PK의 부분집합이 결정자가 되면 안 된다는 조건이고, 부분집합이 결정자가 되는 경우에는 해당 결정 관계를 별도의 테이블로 분리해야 한다.

> [!NOTE] 함수 종속
> 임의의 속성 A의 값이 정해지면 다른 속성 B의 값도 유일하게 정해지는 의존 관계.
> <u>이때 속성 B는 속성 A에 종속하고, 속성 A는 속성 B를 결정한다.</u>
> A → B로 표기하며, A는 B의 결정자, B는 종속 속성이라고 한다.

제 3정규화는 이행적 함수 종속을 제거하는 것. A→B, B→C 가 성립할 때 A→C가 성립되는 경우 이를 별도의 테이블로 분리해야 한다.

BCNF 정규화는 후보키 집합에 속하지 않은 결정자가 없도록 하는 것

각각의 정규화가 제대로 수행되지 않은 테이블에서는 삽입, 갱신, 삭제 이상 현생이 발생할 수 있다.


### 트랜잭션이란?

트랜잭션은 한 번에 실행되어야 하는 작업의 논리적인 단위이다. 기본적으로 ACID의 특성을 가진다.

- Atomic(원자성) - 트랜잭션 내의 작업들은 전부 실행되거나 전부 실행되지 않아야 한다.
- Consistency(일관성) - 트랜잭션 전후로 데이터베이스의 상태에 모순이 없어야 한다.
- Isolation(격리성) - 트랜잭션은 다른 트랜잭션으로부터 독립되어야 한다.
- Durability(영속성) - 트랜잭션 종료 후에는 그 조작이 영구적이 되어야 한다. (로깅, 저장소 저장…)

### 트랜잭션 격리 수준

성능과 정합성 사이의 trade-off → 트랜잭션의 격리성을 어느 범위까지 만족시킬지 설정하는 것이고, 4가지로 구분된다.

- Read Uncommited
    - 가장 낮은 격리 수준으로, 커밋하지 않은 데이터도 접근할 수 있는 수준
    - `Dirty Read`, `Non-Repeatable Read`, `Phantom Read`
- Read Committed
    - 커밋된 데이터만 조회할 수 있는 수준 → 커밋 안 된 데이터는 UNDO 영역에서 예전 값을 읽음
    - `Non-Repeatable Read`, `Phantom Read`
- Repeatable Read
    - 현재 트랜잭션 생성 이전에 커밋된 데이터만 조회할 수 있는 수준
    - UNDO영역에서 데이터를 읽어와야 하는데, `SELECT FOR UPDATE` 로 row lock 걸면 UNDO 영역에서 읽지 못하고 테이블에서 읽어오게 됨
        - → 중간에 다른 트랜잭션이 row를 삽입하는 경우 팬텀리드 발생!
    - `Phantom Read`
- Serializable
    - 직렬화. 항상 Lock 걸고 데이터 조회. 성능 가장 낮음

### 락(Lock)
>트랜잭션이 데이터를 읽거나 쓸 때 충돌 방지를 위해 데이터에 마킹하는 잠금 표식

락을 이용하여 자신이 사용할 데이터를 잠그면 다른 트랜잭션은 잠금이 해제될 때 까지 기다려야 함
락을 사용하면 데이터에 대한 갱신을 순차적으로 진행할 수 있기 때문에 갱신손실 문제를 해결 가능

### 락의 유형
락은 트랜잭션이 다루는 데이터를 다른 트랜잭션이 접근하리 못하도록 막아 대기 상태로 만든다. 다른 트랜잭션을 대기 상태로 만드는 일은 사용자의 응답 시간에 영향을 주기 때문에 가능한 최소화해야 한다. 

트랜잭션이 다루는 데이터는 읽기만 하는 데이터, 읽고 쓰는 데이터, 쓰기만 하는 데이터가 있다. 이 중에서 읽기만 하는 데이터가 있다. 이 중에서 읽기만하는 데이터를 다루는 트랜잭션은 어느 정도 허용해도 문제가 없다. 이 점을 고려하여 락의 유형을 두 가지로 분류한다.

#### 고유락 (Shared Lock / Read Lock)
>여러 트랜잭션이 동일한 자원을 동시에 읽을 수 있도록 허용하는 락

한 트랜잭션이 데이터를 <span style="background:rgba(240, 107, 5, 0.2)">읽고 있을 때</span>, 다른 트랜잭션이 동일한 데이터를 읽을 수 있지만, 쓸 수는 없음
읽기만 할 때는 데이터의 변경이 일어나지 않으므로, 읽기에 한해 동시 작업을 허용하는 것

#### 배타락 (Exclusive Lock / Write Lock)
>특정 자원에 대한 R/W 권한을 가진 트랜잭션이 독점적으로 해당 자원을 사용할 수 있는 락

한 트랜잭션이 데이터를 <span style="background:rgba(240, 107, 5, 0.2)">쓰고 있을 때</span>,다른 트랜잭션이 동일한 데이터를 읽거나 쓸 수 없음
데이터를 수정하는 경우나 쓰기 작업을 수행할 때 사용

### 2단계 락킹
락을 사용하면 갱신 손실 문제를 해결할 수 있지만, 락을 걸고 해제하는 시점에 제한이 없다면 다수의 트랜잭션 동시 실행 시 데이터의 일관성이 깨질 수 있다.
→ 락을 해제하고 다시 거는 중간 순간에 다른 트랜잭션이 락이 해제된 데이터를 볼 수 있음
→ 이와 같은 상황 방지를 위해 2단계 락킹 기법을 사용
-> 트랜잭션이 락을 걸고 해제하는 시점을 아래와 같이 2단계로 관리
- 확장: 락 획득 단계. 이미 획득한 락을 해제하지 않음
- 수축: 릭 해제 단계. 새로운 락을 획득하지 않음

### Dead Lock
2단계 락킹 방법을 사용하면 데이터의 일관성을 유지할 수 있지만, 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대하여 락을 요청하면 무한 대기 상태에 빠질 수 있다. 이러한 현상을 데드락(Deadlock)이라 한다.

```
먼 길 - 윤석중

아기가 잠드는 걸  
보고 가려고  
아빠는 머리맡에  
앉아 계시고.  
아빠가 가시는 걸  
보고 자려고  
아기는 말똥말똥  
잠을 안 자고.
```

Recource Allocation Graph 를 그려 교착 상태를 확인할 수 있음 (방향 그래프))
하나의 트랜잭션을 노드로, 락 요청을 화살표로 표현한다.
RAG에서 사이클이 존재하면 데드락 발생 확률이 존재한다는 의미.
