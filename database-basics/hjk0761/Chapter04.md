# 스터디 2회차(2024.08.07)

## 목차
1. [정규화](#정규화)
    a. [정규화란?](#정규화란)
    b. [NF](#nfnormal-form)
    c. [1NF](#1nf)
    d. [2NF](#2nf)
    e. [3NF](#3nf)
    f. [BCNF](#bcnf)
2. [트랜잭션](#트랜잭션)
3. [락](#락)

# 정규화

## 정규화란?
데이터베이스에서 정규화는 관계형 데이터베이스에서 normal form이라고 부르는 형태를 만들기 위한 과정입니다. 이를 통해 데이터 중복을 줄이고 데이터 무결성을 향상시킵니다.

일반적으로 크기가 크고 조직화 되지 않은 테이블을 작고 잘 조직된 테이블로 나누는 행위이며, 이를 통해 한 테이블에서의 데이터의 삽입, 삭제, 변경이 정의된 관계들을 통해 나머지 테이블까지 전파되게 하는 것이다.

Normal Form 은 크게 1NF, 2NF, 3NF, BCNF 등이 있으며, 보통 3NF 화 되었으면 정규화 되었다고 표현한다. 일반적으로 완전히 정규화되게 데이터베이스는 디자인되지만, 일부 성능상의 이유로 비정규화를 따를 수 있다.

## NF(Normal Form)

 - 목적

제 1 정규화의 목적은 다음과 같다.
1. 관계들의 집합을 예상치 못한 삽입, 갱신, 삭제 의존으로부터 자유롭게 한다.
2. 새로운 형태의 데이터가 들어오거나, 프로그램의 생명 주기가 늘어나는 상황에서 관계들의 집합을 재정의할 필요를 줄인다.
3. 관계형 모델이 사용자들에게 정보 전달을 용이하게 한다.
4. 관계들의 집합을 시간에 따라 바뀌는 질의에 대한 통계로부터 중립적이게 한다.

 - 좀 더 자세히
### 삽입 이상
명백한 사실이 기록되지 못하는 환경이 있다. 예를 들어 '교수와 담당과목' 관계에서 교수 ID, 교수 이름, 고용된 날짜, 담당 과목을 가질 때, 신임 교수는 담당과목이 없는 상황이기에 이 관계에 삽입될 때 담당 과목 부분이 null이기 때문에 제약조건에 따라 삽입할 수 없을 수 있다.

### 갱신 이상
같은 정보가 여러 행에 있는 경우에 문제가 발생한다. 이런 관계를 갱신할 때 같은 값 중 어느 값을 갱신할지에 따라 논리적 모순이 발생할 수 있다. 

### 삭제 이상
어떤 정보를 삭제하면서 삭제되면 안되는 다른 정보들도 삭제되는 현상이다. 이전의 교수와 담당과목 관계에서 교수가 퇴직하지 않았음에도 수업을 그만둘 때 교수의 정보까지 삭제된다.


 - 재설계 최소화
정규화된 데이터베이스는 기존 구조의 변경 없이 새로운 형태의 정보를 받을 수 있다. 이는 프로그램이 데이터베이스에 최소한의 영향을 주고 상호작용할 수 있음을 의미한다.

### 1NF

조건
1. 열에는 위-아래의 순서가 없다.
2. 행에는 좌-우 순서가 없다.
3. 중복되는 열이 없다.
4. 모든 열과 행의 중복지점에는 해당하는 분야에서 단 한 개의 값을 가져야 한다.
5. 모든 행은 규칙적이다. 즉, 열은 숨어있는 요소를 가지지 않는다.

이를 만드는 방법은 다음과 같다.
- 각 테이블에서 중복을 제거한다.
- 각각 관계된 데이터 모임을 위하여 분리된 테이블을 만든다.
- 각각 관계된 데이터 모임을 기본키로 식별한다.

### 2NF

제 1 정규화인 테이블에 대해서, 후보키 k 와 k 에 속하지 않는 속성 a가 있을 때, a를 결정하기 위해 k의 일부가 아닌 k 전체를 참조해야한 하는 경우이다(부분적 종속이 없어야 한다 = 모든 컬럼의 완전 함수 종속 만족).
쉽게 말해, 기본키 중 특정 컬럼에만 종속된 컬럼이 없을 때 제 2 정규화이다.

이를 만들기 위해선
특정 컬럼에만 종속된 컬럼을 의존하는 컬럼과 함께 분리한다.

### 3NF

제 2 정규화를 만족하는 테이블에 대해, 테이블 내의 키가 아닌 모든 컬럼이 테이블의 모든 키에 이행적 종속이 되지 않으면 제 3 정규화이다.
다시 말해, 제 2 정규화인 테이블이면서 이행적 종속이 없어야 한다(x->y, y->z 일 때 x->z 를 이행 종속이라고 표현함).

### BCNF
(Boyce-Codd Normal Form)

제 3 정규화인 릴레이션 R에 대해, 함수 종속성 X->Y가 성립할 때, 모든 결정자 X가 후보키이면 BCNF라고 한다.

# 트랜잭션

## 정의
데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위
작업의 단위는 질의어 한 문장이 아니다

## 특징
### 원자성(Atomicity)
트랜잭션은 모두 반영되거나, 모두 반영되지 않아야 한다.
### 일관성(Consistency)
작업 처리 결과가 일관성이 있어야 한다.
트랜직션이 진행되는 동안 데이터베이스가 변경되더라도 변경 이전의 트랜잭션을 시작한 시점에서의 데이터베이스로 트랜잭션을 진행해야 한다.
### 독립성(Isolation)
둘 이상의 트랜잭션이 동시에 실행되는 경우, 어느 트랜잭션도 다른 트랜잭션의 연산에 끼어들 수 없다.
하나의 트랜잭션이 완료되지 전까지, 다른 트랜잭션은 그 트랜잭션의 결과를 참조할 수 없다.
### 지속성(Durability)
트랜잭션이 성공적으로 완료된 경우 이 결과는 영구적으로 반영되어야 한다.

## 연산
##commit
한 트랜잭션이 끝났고, 현재의 데이터베이스가 데이터 일관성을 지키는 상태에 있을 때 트랜잭션이 끝났음을 알려주는 연산이다.
commit 이 수행되면 수행한 트랜잭션이 로그에 저장되어 이후 rollback을 트랜잭션 단위로 수행할 수 있도록 도와준다.
### rollback
하나의 트랜잭션이 비정상적으로 종료되어 원자성이 깨져, 이 트랜잭션을 처음부터 다시 시작하거나 연산된 결과를 취소하는 연산이다.

## 복구
### UNDO
사용자가 했던 작업을 취소(무효화) => 롤백
읽기 일관성을 위해 존재
UNDO SEGMENT 로 UNDO 지점을 표시
방법: 로그를 역방향 탐색하면서 UNDO 복구가 필요한 로그를 찾아 이에 해당하는 UNDO 연산 수행, UNDO 작업에 대한 REDO 로그 기록, 이전 로그를 계속 탐색하며 해당 트랜잭션의 시작 로그까지 반복
### REDO
취소한 작업을 다시 복구 => 커밋했던 트랜잭션을 재반영
REDO 로그에 기록
방법: 체크 포인트부터 REDO 로그를 따라가면서 재수행

### 비정상 종료시
REDO(마지막 체크포인트부터 장애시점까지 복구) - UNDO(커밋하지 않은 데이터 롤백)

# 락

## 목적
여러 커넥션에서 동일한 자원을 요청한 경우 순서대로 하나의 커넥션만 연결될 수 있도록 하는 기능이다.
동시성을 제어하면서 데이터의 일관성을 지키기 위해 사용한다.

## 종류
1. 공유 락(Shared Lock, Read Lock)
데이터를 변경하지 않는 읽기 작업을 보장하기 위한 락이다.
한 세션에서 읽기를 수행하는 동안 다른 세션에서의 읽기 작업은 데이터 정합성이 지켜지기 때문에 공유 락 획득은 허용하고,
다른 세션에서 쓰기 작업은 정합성을 위배하기 때문에 배타적 락 획득은 막는다.
2. 배타적 락(Exclusive Lock, Write Lock)
데이터를 변경하는 쓰기 작업을 보장하기 위한 락이다.
한 세션에서 쓰기 작업을 수행하는 동안 다른 세션에서의 읽기, 쓰기 작업 모두 정합성을 해칠 수 있으므로 공유 락, 배타적 락 모두 획득을 막는다.

## 블로킹
락도 트랜잭션 단위로 획득하고 해제하는데, 이 때 락 간의 경합으로 인해 한 트랜잭션이 작업을 이어하지 못하는 상태를 말한다.
쓰기 작업 중에 같은 공간에 읽기 작업을 수행하는 등의 상황에서 발생한다.
블로킹된 트랜잭션은 락이 걸린 자원을 공유한 다른 트랜잭션이 commit 되거나 rollback 되지 않는다면 timeout 으로 rollback 된다.

## 데드락
같은 데이터를 바라보는 트랜잭션들이 모두 블로킹되어 서로의 블로킹을 해결할 수 없는 상태이다.

### 발생 조건
1. 상호배제(Mutual exclusion) : 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
2. 점유대기(Hold and wait) : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
3. 비선점(No preemption) : 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
4. 순환대기(Circular wait) : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.
위 모든 조건이 충족된 상태에서만 데드락이 발생할 수도 있다.

### 해결
위 조건을 발생 전에 미리 해소할 수도 있지만, 코스트가 크다.
따라서 Resource Allocation Graph Algorithm, Banker's algorithm 등의 알고리즘을 통해 자원 할당 상태를 파악하고,
데드락이 발생할 만한 상황을 회피하도록 수정한다.