#DB훑어보기 - 2
# 이상현상
## 1. 삭제이상
특정 튜플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상
-> 의도했던 행동 외 다른 정보가 삭제되는 현상
## 2. 삽입이상
튜플 삽입 시 특정 속성에 해당하는 값이 없어 NULL이 입력되는 현상
## 3. 수정이상
튜플 수정 시 중복된 데이터의 일부만 수정되어 데이터의 불일치 문제가 일어나는 현상

# 함수 종속성
이상현상이 발생하는 테이블을 수정하여 정상으로 만드는 과정을 정규화라고 하는데, 정규화를 하기 위해선 기본키와 함수 종속성을 파악해야 한다.

함수 종속성 : 어떤 속성 A의 값을 알면 다른 속성 B의 값이 유일하게 정해지는 의존관계를 `속성 B는 속성 A에 종속한다`, `속성 A는 속성 B를 결정한다` 라고하며, `A->B`로 표기한다. 또한 A는 B의 결정자라고 한다.
# 정규화
## 제 1정규형
릴레이션의 속성 값이 원자값이어야 한다. 즉, 모든 속성 값은 한 칼럼에 한 개씩만 있어야 한다.
ex) (이름, 취미) -> (김연아, 영화), (추신수, (쇼핑, 음악))은 안됨

## 제 2정규형
기본키가 복합키일 때, 복합키의 일부분이 다른 속성의 결정자인지 여부를 판단한다.
현재 1정규형을 만족하면서, 기본키가 아닌 속성이 기본키에 완전 함수 종속일 때 제 2정규형이라 한다.
후보키 k와 K에 속하지 않는 속성 A가 있을 때, A를 결정하기 위해 K의 일부가 아닌 K전체를 참조해야만 하는 경우를 말한다. 즉, 부분함수종속관계를 전부 완전함수종속 관계로 만드는 것이다.

완전 함수 종속 : A와 B가 릴레이션 R의 속성이고, A->B 종속성이 성립할 때, B가 A의 속성 전체에 함수 종속하고 부분집합 속성에 함수 종속하지 않을 경우 완전 함수 종속이라고 한다.

ex) (학생번호, 강좌이름, 강의실, 성적) 릴레이션의 기본키는 (학생번호, 강좌이름)이라고 하자.
또한 여기에는 강좌이름->강의실 종속관계를 가지고 있다.
- 삭제이상 : 특정 학생이 수강을 취소하면 그 과목에 대한 강의실 정보가 사라짐
- 삽입이상 : 새 과목이 개설되었는데 신청한 학생이 없다면 NULL값이 생성됨
- 수정이상 : 특정 과목의 강의실을 다른 강의실로 변경하면 데이터 불일치가 발생
따라서 이상현상을 일으키는 (강좌이름, 강의실)을 분해함으로 제 2정규형을 만족할 수 있다.
-> (학생번호, 강좌이름, 성적), (강좌이름, 강의실)

## 제 3정규형
속성들이 이행적으로 종속되어 있는지 여부를 판단한다. 이행적 종속은 A->B, B->C가 성립할 때, A->C가 성립되는 함수 종속성을 말한다.
제 3정규형은 비이행적으로 종속되어야 한다(K->C, K->A).

ex) (학생번호, 강좌이름, 수강료) 릴레이션이 있다고 하자.
- 삭제이상 : 학생이 수강을 취소하면 수강료에 대한 정보가 사라짐
- 삽입이상 : 과목이 개설되어 수강료를 삽입해야 하는데, 신청한 학생이 없어 NULL 값을 넣어야 함
- 수정이상 : 수강료 변경 시 데이터 불일치 발생 가능
수강료는 기본키가 아닌 강좌이름에 한 번 더 종속되어 있음

(강좌이름, 수강료)를 분리하면...
-> (학생번호, 강좌이름), (강좌이름, 수강료)

## BCNF
존재하는 함수 종속성에서 모든 결정자가 후보키일 때 BCNF 정규형(X->Y일 때, 모든 결정자 X가 후보키인 상황)

ex) (학생번호, 특강이름, 교수) 릴레이션이 있다고 하자.
- 삭제이상 : 학생이 수강취소를 하면 그 과목을 담당하는 교수 정보가 사라짐
- 삽입이상 : 과목 개설 시 수강하는 학생이 없어 번호를 NULL로 추가해야 함
- 수정이상 : 특강 제목을 변경하면 데이터 불일치 발생 가능
이 릴레이션의 기본키는 (학생번호, 특강이름)이다.
(학생번호, 특강이름)->교수, 교수->특강이름의 관계가 성립되며, 이 릴레이션의 결정자 중 (학생번호, 특강이름)은 후보키지만 교수는 후보키가 아니다.
즉, 결정자면서 후보키가 아닌 속성이 존재하면 이상현상이 발생한다.

(학생번호, 특강이름, 교수)에서
(학생번호, 교수), (특강이름, 교수)로 분리할 수 있겠다.

## 제4정규형 
멀티밸류 종속성(MVD)이 존재할 때, 모든 비트리비얼 멀티밸류 종속성이 후보키를 포함할 때 제4정규형(4NF)이 성립합니다.

**릴레이션 예시:** (학생번호, 프로젝트명, 자격증명) 릴레이션이 있다고 하자.

- **삭제 이상:** 한 학생이 한 프로젝트에서 제거되면, 그 학생이 보유한 자격증명 정보도 함께 사라짐.
- **삽입 이상:** 특정 프로젝트에 새 학생을 추가하려면 그 학생의 자격증명도 함께 추가해야 함.
- **수정 이상:** 특정 학생의 자격증명을 변경하면 여러 튜플에 대한 수정이 필요함.

이 릴레이션의 기본키는 (학생번호, 프로젝트명, 자격증명)입니다. 릴레이션에는 두 가지 멀티밸류 종속성이 존재합니다:

1. 학생번호 ->> 프로젝트명 (한 학생이 여러 프로젝트에 참여할 수 있음)
2. 학생번호 ->> 자격증명 (한 학생이 여러 자격증명을 가질 수 있음)

위의 예시에서 비트리비얼 멀티밸류 종속성 (학생번호 ->> 프로젝트명)과 (학생번호 ->> 자격증명) 모두 후보키인 학생번호에 대해 성립합니다.

그러나 (학생번호, 프로젝트명, 자격증명)의 구조에서는 멀티밸류 종속성으로 인해 삽입, 삭제, 수정 이상이 발생할 수 있습니다. 이를 해결하기 위해 제4정규형으로 분해해야 합니다.

릴레이션을 두 개로 분해할 수 있습니다:

1. (학생번호, 프로젝트명)
2. (학생번호, 자격증명)

이렇게 분해하면 각 릴레이션에서 멀티밸류 종속성에 따른 이상현상이 사라지며, 제4정규형을 만족하게 됩니다.

### 요약

**제4정규형(4NF)**은 다음과 같은 상황을 해결합니다:

- **멀티밸류 종속성으로 인한 이상현상**
    - 비트리비얼 멀티밸류 종속성이 후보키에 대해 성립하지 않는 경우.
    - 이를 해결하기 위해 멀티밸류 종속성을 분해하여 독립된 릴레이션으로 나누어야 합니다.

위의 예시와 같이 멀티밸류 종속성을 만족하는 릴레이션을 제4정규형으로 분해하면 데이터의 일관성을 유지할 수 있고, 이상현상을 방지할 수 있습니다.

## 제5정규형 (5NF)

조인 종속성(JD)이 존재할 때, 모든 조인 종속성이 후보키를 통해 성립하는 경우 제5정규형(5NF)이 성립합니다.

#### 예시

**릴레이션 예시:** (학생번호, 과목명, 교수명) 릴레이션이 있다고 하자.

- **삭제 이상:** 한 학생이 특정 과목을 수강 취소하면 그 과목을 담당하는 교수 정보가 사라질 수 있음.
- **삽입 이상:** 새로운 교수를 추가하려면 해당 교수가 가르치는 과목과 이를 수강하는 학생 정보를 모두 추가해야 함.
- **수정 이상:** 특정 과목을 가르치는 교수가 변경되면 여러 튜플을 수정해야 함.

이 릴레이션의 기본키는 (학생번호, 과목명, 교수명)입니다.

릴레이션에는 다음과 같은 조인 종속성이 존재합니다:

1. 학생번호와 과목명은 교수명에 종속됨.
2. 학생번호와 교수명은 과목명에 종속됨.
3. 과목명과 교수명은 학생번호에 종속됨.

위의 예시에서 비트리비얼 조인 종속성 (학생번호, 과목명)과 (교수명), (학생번호, 교수명)과 (과목명), (과목명, 교수명)과 (학생번호) 모두 후보키를 포함하지 않는 경우 이상현상이 발생할 수 있습니다.

### 5NF로의 분해

릴레이션을 세 개로 분해할 수 있습니다:

1. (학생번호, 과목명)
2. (과목명, 교수명)
3. (학생번호, 교수명)

이렇게 분해하면 각 릴레이션에서 조인 종속성에 따른 이상현상이 사라지며, 제5정규형을 만족하게 됩니다.

### 요약

**제5정규형(5NF)**은 다음과 같은 상황을 해결합니다:

- **조인 종속성으로 인한 이상현상**
    - 비트리비얼 조인 종속성이 후보키에 대해 성립하지 않는 경우.
    - 이를 해결하기 위해 조인 종속성을 분해하여 독립된 릴레이션으로 나누어야 합니다.

# 트랜잭션
DBMS에서 데이터를 다루는 논리적인 작업의 단위
장애를 복구하거나 작업을 분리하는 단위

트랜잭션은 시작되거나 시작되지 않아야 한다.

## ACID
Atomicity - 원자성 : 트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 않아야 한다.
Consistency - 일관성 : 트랜잭션을 수행하기 전이나 수행한 후나 DB는 항상 일관된 상태를 유지해야 한다.
Isolation - 고립성 : 수행중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하는 일이 없어야 한다.
Durability - 지속성 : 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.저장된 DB는 저장 직후 발생할 수 있는 정전, 장애 등에 영향받지 말아야 한다.

- 트랜잭션 중간에 작업이 잘못되거나 중단되면 회복 알고리즘을 이용해 내용 변경을 취소하고 이전 상태로 복구한다.
- SAVEPOINT(저장점) : 트랜잭션의 길이가 길때 트랜잭션의 중간 지점에 수정 내용을 되돌리는 포인트를 만든다. 여러 저장점을 만들 수 있다.
- 트랜잭션 제어 명령어(Transaction Control Language, TCL) : COMMIT, ROLLBACK 

## 트랜잭션 읽기 / 쓰기 시나리오

| 상황   | 트랜잭션 1 | 트랜잭션 2 | 발생 문제                     | 동시 접근          |
| ---- | ------ | ------ | ------------------------- | -------------- |
| 상황 1 | 읽기     | 읽기     | 없음(읽기만 하면 아무 문제가 없음)      | 허용             |
| 상황 2 | 읽기     | 쓰기     | 오손 읽기, 반복불가능 읽기, 유령데이터 읽기 | 허용/불가 중 선택     |
| 상황 3 | 쓰기     | 쓰기     | 갱신 손실(절대 허용하면 안 됨)        | 허용 불가(LOCK 이용) |
- 갱신 손실(lost update) : 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 발생한다.

# 락
- 트랜잭션이 데이터를 읽거나 수정할 때 데이터에 표시하는 잠금 장치
- 다른 트랜잭션이 접근하지 못하게 막아 대기 상태로 만든다.
- 락을 이용하여 데이터를 잠그면 다른 트랜잭션은 락이 풀릴 때까지 기다려야 한다.
- 락을 사용하면 갱신을 순서대로 진행할 수 있어 갱신 손실 문제를 해결할 수 있다.
- 트랜잭션이 다루는 데이터를 다른 트랜잭션이 접근하지 못하도록 막아 대기 상태로 만든다.
- 다른 트랜잭션을 대기 상태로 만드는 일은 사용자 응답시간에 영향을 주기 때문에 가능한 최소화해야 한다.
- 공유락 - 읽기를 표시하는 락
- 배타락 - 읽기/쓰기를 할 때 사용하는 락

### 공유 / 배타락 사용 규칙
- 데이터에 락이 걸려 있지 않을 때 트랜잭션은 데이터에 락을 걸 수 있다.
- 트랜잭션이 데이터 X를 읽기만 하면 LS(X)를 요청하고, 읽고 쓰기를 하면 LX(X)를 요청한다
- 트랜잭션 T1이 데이터에 LS(X)를 걸어두면, 트랜잭션 T2의 LS(X) 요청은 허용하고 LX(X)는 허용하지 않는다.
- 트랜잭션 T1이 데이터에 LX(X)를 걸어두면, 트랜잭션 T2의 LS(X)와 LX(X) 모두 허용하지 않는다.
- 트랜잭션이 락을 허용받지 못하면 대기 상태가 된다.

### 락 호환 행렬
|       | LS 상태 | LX 상태 |
| ----- | ----- | ----- |
| LS 요청 | 허용    | 대기    |
| LX 요청 | 대기    | 대기    |

### 2단계 락킹
- 데이터에 락을 걸었다가 풀고 다른 데이터에 락을 거는 중간 과정에서 락의 해지 상태가 생기면서 다른 트랜잭션에게 일관성이 깨진 데이터의 중간 결과를 보이는 것을 방지하기 위한 기법
- 트랜잭션이 락을 걸고 해제하는 시점을 2단계로 나누어 진행한다.

### 확장 단계
- 트랜잭션이 필요한 락을 획득하는 상태
- 이미 획득한 락을 해제하지 않는다.

### 수축 단계
- 트랜잭션이 락을 해제하는 상태
- 새로운 락을 획득하지 않는다.

### 데드락
- 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대해 락을 요청하면 무한 대기 상태에 빠질 수도 있다(교착상태).

# 트랜잭션 고립 수준
### 오손 읽기(Dirty Read)
- 트랜잭션 1이 쓰기 작업을 하는 트랜잭션 2가 작업한 중간 데이터를 읽어서 생기는 문제
- 트랜잭션 2가 어떤 이유로 작업을 철회(ROLLBACK)할 때 트랜잭션 1은 무효화된 데이터를 읽게 되고 잘못된 결과를 도출한다.

### 반복 불가능 읽기(Non Repeatable Read)
- 트랜잭션 1이 데이터를 읽고 트랜잭션 2가 데이터를 쓰고(갱신, UPDATE), 트랜잭션 1이 다시 한 번 데이터를 읽을 때 생기는 문제
- 트랜잭션 1이 읽기 작업을 다시 한 번 반복할 경우 이전의 결과가 반복되지 않는 현상을 말함

### 유령데이터 읽기(Phantom Read)
- 트랜잭션 1이 데이터를 읽고 트랜잭션 2가 데이터를 쓰고(삽입, INSERT), 트랜잭션 1이 다시 한 번 데이터를 읽을 때 생기는 문제
- 트랜잭션 1이 읽기 작업을 다시 한 번 반복할 경우 이전에 없던 데이터(유령 데이터)가 나타나는 현상을 말한다.
