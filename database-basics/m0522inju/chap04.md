# 정규화, 트랜잭션, 락

# 정규화

- 잘못 설계된 테이블을 수정하여 데이터의 일관성과 무결성을 회복시키는 프로세스
- 데이터의 중복성과 종속성을 제거하여 데이터베이스의 효율성과 유지보수성을 향상시킬 수 있다.
- 데이터의 논리적 구조를 개선하고 데이터베이스의 성능을 최적화하는 데 도움이 된다.

## 이상현상

- 데이터 조작 작업(삽입, 삭제, 수정)에 따라 테이블의 일관성을 훼손하여 데이터의 무결성을 깨뜨리는 현상

### 주요 이상현상

- `삽입`
  - 부득이하게 NULL값 입력
  - 중복 데이터 삽입 ➡️ 데이터의 중복성 증가
- `삭제`
  - 연쇄 삭제(triggered deletion) 현상 : 필요한 데이터가 함께 삭제됨
- `수정`
  - 일관성 없음(inconsistency) 문제 : 테이블의 속성 간 일관성이 깨짐

## 함수 종속성(FD, Functional Dependency)

### A → B

- 어떤 속성 A의 값을 알면 다른 속성 B의 값이 유일하게 정해지는 의존 관계
- `속성 B는 속성 A에 종속한다(dependent)`
- `속성 A는 속성 B를 결정한다(determine)`
- A == B의 결정자
- B == 종속 속성

### 함수 종속성 다이어그램(functional dependency diagram)

- 릴레이션의 속성 : 직사각형
- 속성 간의 함수 종속성 : 화살표
- 복합 속성 : 직사각형으로 묶음
- `결정자가 복합 속성일 수 있다`

<img width="639" alt="스크린샷 2024-08-04 오후 8 11 08" src="https://github.com/user-attachments/assets/eaf4c228-aa05-4bd4-a49b-45baa4986d9a" />

- `학생번호` + `강좌이름` ➡️ `성적`

### 함수 종속성과 기본키

- 기본키는 릴레이션의 모든 속성에 대해 `결정자`이다.
  - K(PK) → R

### 이상현상과 결정자

- 이상현상은 기본키가 아니면서 결정자인 속성이 있을 때 발생한다.

## 정규화(normalization)

> 이상현생이 발생하는 릴레이션을 분해하여 이상현상을 없애는 과정

### 정규화 과정

- 정규형이 높을수록 이상현상은 줄어든다.'

#### 제1정규형

> A relation in which the intersection of each row and column contains one and only one value.

- 릴레이션의 속성값이 원자값이어야 한다.
- 릴레이션이 갖춰야 할 기본적인 성질

#### 제2정규형

> A relation that is in first normal form and every non-primary key attribute is fully functionally dependent on the primary key.

- 릴레이션의 기본키가 복합키로 구성되어 있을 때, 복합키의 일부분이 다른 속성의 결정자인지 여부를 판단하는 것
- **완전 함수 종속** : A와 B가 릴레이션 R의 속성이고 A → B 종속성이 성립할 때, B가 A의 속성 전체에 함수 종속하고 부분집합 속성에 함수 종속하지 않을 때
- 불완전 함수 종속(부분 함수 종속) : A → B 종속성에서 A의 속성 일부를 제거해도 종속성이 여전히 성립하는 경우

#### 제3정규형

> A relation that is in first and second normal form and in which no non-primary key is transitively dependent on the primary key.

- 속성들이 모두 이행적으로 종속되어 있는지를 판단하는 것
- A → B, B → C가 성립할 때 A → C가 성립되는 함수 종속성

#### BCNF

> A relation is in BCNF if and only if every determinant is a candidate key.

- 릴레이션에 있는 함수 종속성에서 모든 결정자가 후보키인 경우
- 함수 종속성 X → Y가 성립할 때 모든 결정자 X가 후보키
- 결정자이면서 후보키가 아닌 속성이 존재하면 이상현상이 발생한다.

#### 무손실 분해

- 릴레이션 R을 두 개의 릴레이션 R1과 R2로 분해했을 때, 다시 조인하면 원래의 릴레이션 R이 만들어지는 것

# 트랜잭션

## 트랜잭션의 개념

- DBMS에서 데이터를 다루는 논리적인 작업의 단위
- 데이터를 다룰 때 장애 시 데이터를 복구하는 작업의 단위
- 여러 작업이 동시에 같은 데이터를 다룰 때 작업을 서로 분리하는 단위
- **all or noting** 전체가 수행되거나 전혀 수행되지 않아야 한다.

## 트랜잭션의 성질

### `1` 원자성(Atomicity)

- 트랜잭션이 원자처럼 더 이상 쪼개지지 않는 하나의 프로그램 단위로 동작해야 한다.
- 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다.
- 트랜잭션 중간에 작업이 잘못되거나 중단되면 회복(recovery) 알고리즘을 이용해 변경한 내용을 취소하고 이전 상태로 복구한다.
- 트랜잭션 제어 명령어(TCL, Transaction Control Language) : COMMIT, ROLLBACK
- SAVEPOINT(저장점) : 트랜잭션의 길이가 길면 트랜잭션의 중간 지점에 수정 내용을 되돌리는 포인트를 만든다.
  - 트랜잭션 안에 여러 개 만들 수 있다.

### `2` 일관성(Consistency)

- 트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.
- 수행 중 일시적으로 일관성을 유지하지 못하는 상태가 있을 수 있다.

### `3` 고립성(Isolation)

- 여러 트랜잭션이 동시에 수행될 때 상호 간섭이나 데이터 충돌이 일어나지 않는 현상
- 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 한다.
- 변경 중인 임시 데이터를 다른 트랜잭션이 읽거나 쓰려고 할 때 제어하는 작업이 필요하다.
- `동시성 제어(concurrency control)` : 변경 중인 데이터를 다른 트랜잭션이 사용하면 데이터의 일관성이 훼손되지 않게 서로 충돌하지 않도록 제어하는 작업

### `4` 지속성(Durability)

- 트랜잭션이 정상적으로 완료되거나 부분 완료된 데이터는 반드시 데이터베이스에 기록되어야 한다.
- 저장된 데이터베이스는 저장 직후 혹은 어느 때나 발생할 수 있는 정전, 장에, 오류에 영향을 받지 않아야 한다.
- `부분 완료(partially comitted)` : 트랜잭션 수행은 완료되었지만 변경 내용이 데이터베이스에 기록되었는지 확실하지 않은 상태
- `실패(failed)` : 트랜잭션을 중간에 중단하였거나 부분 완료 상태에서 변경 내용을 데이터베이스에 저장하지 못한 상태.

## 동시성 제어(concurrency control)

- 트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능

#### 트랜잭션의 읽기/쓰기 시나리오

| 상황   | 트랜잭션 1 | 트랜잭션 2 | 발생 문제                                   | 동시 접근            |
| ------ | ---------- | ---------- | ------------------------------------------- | -------------------- |
| 상황 1 | 읽기       | 읽기       | 없음(읽기만 하면 아무 문제가 없음)          | 허용                 |
| 상황 2 | 읽기       | 쓰기       | 오손 읽기, 반복불가능 읽기, 유령데이터 읽기 | 허용/불가 중 선택    |
| 상황 3 | 쓰기       | 쓰기       | 갱신 손실(절대 허용하면 안 됨)              | 허용 불가(LOCK 이용) |

### 갱신 손실 문제

- 갱신 손실(lost update) 문제는 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 발생한다.

## 락(lock)

- 트랜잭션이 데이터를 읽거나 수정할 때 데이터에 표시하는 잠금장치
- 락을 이용하여 자신이 사용할 데이터를 잠그면 다른 트랜잭션은 잠금이 풀릴 때까지 기다려야 한다.
- 락을 사용하면 갱신을 순차적으로 진행할 수 있으므로 갱신 손실 문제가 해결된다.
- 트랜잭션이 다루는 데이터를 다른 트랜잭션이 접근하지 못하도록 막아 대기 상태로 만든다.
  - 다른 트랜잭션을 대기 상태로 만드는 일은 사용자 응답시간에 영향을 주기 때문에 가능한 최소화해야 한다.

### 공유락(LS, shared lock)과 배타락(LX, exclusive lock)

- **공유락** : 트랜잭션이 읽기를 할 때 사용하는 락
- **배타락** : 읽기/쓰기를 할 때 사용하는 락

#### 공유락과 배타락을 사용하는 규칙

- 데이터에 락이 걸려 있지 않으면 트랜잭션은 데이터에 락을 걸 수 있다.
- 트랜잭션이 데이터 X를 읽기만 하면 LS(X)를 요청하고, 읽고 쓰기를 하면 LX(X)를 요청한다
- 트랜잭션 T1이 데이터에 LS(X)를 걸어두면, 트랜잭션 T2의 LS(X) 요청은 허용하고 LX(X)는 허용하지 않는다.
- 트랜잭션 T1이 데이터에 LX(X)를 걸어두면, 트랜잭션 T2의 LS(X)와 LX(X) 모두 허용하지 않는다.
- 트랜잭션이 락을 허용받지 못하면 대기 상태가 된다.

#### 락 호환행력(lock compatibility matrix)

> 트랜잭션의 공유락은 상호 허용되지만 배타락은 상호 허용되지 않는다.

|         | LS 상태 | LX 상태 |
| ------- | ------- | ------- |
| LS 요청 | 허용    | 대기    |
| LX 요청 | 대기    | 대기    |

### 2단계 락킹(2 phase locking)

- 데이터에 락을 걸었다가 풀고 다른 데이터에 락을 거는 중간 과정에서 락의 해지 상태가 생기면서 다른 트랜잭션에게 일관성이 깨진 데이터의 중간 결과를 보이는 것을 방지하기 위한 기법
- 트랜잭션이 락을 걸고 해제하는 시점을 2단계로 나누어 진행한다.

#### 확장단계(growing phase)

- 트랜잭션이 필요한 락을 획득하는 단계
- 이미 획득한 락을 해제하지 않는다.

#### 수축단계(shrinking phase)

- 트랜잭션이 락을 해제하는 단계
- 새로운 락을 획득하지 않는다.

### 데드락(deadlock)

- 교착상태
- 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대해 락을 요청할 때 무한 대기 상태에 빠지는 것
- 데드락이 발생하면 DBMS는 작업 하나를 강제로 중지시킨다.
  - 중지시키는 트랜잭션에서 변경한 데이터는 원래 상태로 되돌려 놓는다.

## 트랜잭션 고립 수준

### 트랜잭션 동시 실행 문제

#### 오손 읽기(dirty read)

- 읽기 작업을 하는 트랜잭션 1이 쓰기 작업을 하는 트랜잭션 2가 작업한 중간 데이터를 읽을 때 생기는 문제

#### 반복불가능 읽기(non-repeatable read)

- 트랜잭션 1이 데이터를 읽고 트랜잭션 2가 데이터를 쓰고(갱신, UPDATE) 트랜잭션 1이 다시 한번 데이터를 읽을 때 생기는 문제.

#### 유령데이터 읽기(phantom read)

- 트랜잭션 1이 데이터를 읽고 트랜잭션 2가 데이터를 쓰고(삽입, INSERT) 트랜잭션 1이 다시 한번 데이터를 읽을 때 생기는 문제
  - 트랜잭션 1이 읽기 작업을 다시 한번 반복할 때 이전에 없던 데이터가 보이는 현상
- MySQL에서는 발생하지 않는다.
  - REPEATABLE READ 모드에서는 처음 데이터를 읽어올 때 SNAPSHOT을 구축하여 자료를 가져온다.
  - 다른 세션의 자료가 변경되더라도 동일한 결과를 보여주게 된다.

### 트랜잭션 고립 수준 명령어

- 락을 사용해 트랜잭션의 동시성이 과하게 제한되는 것을 방지하기 위해 동시성을 높이는 명령어 == **트랜잭션 고립 수준 명령어(transaction isolation level instruction)**를 제공하여 락을 완화한다.
- 사용자가 어느 정도 선택적으로 트랜잭션의 동시성을 제어할 수 있다.

|                  | 오손 읽기 | 반복불가능 읽기 | 유령데이터 읽기 |
| ---------------- | --------- | --------------- | --------------- |
| READ UNCOMMITTED | 가능      | 가능            | 가능            |
| READ COMMITTED   | 불가능    | 가능            | 가능            |
| REPEATABLE READ  | 불가능    | 불가능          | 가능            |
| SERIALIZABLE     | 불가능    | 불가능          | 불가능          |

#### READ UNCOMMITTED(Level=0)

- 고립 수준이 가장 낮은 명령어
- 자신의 데이터에 아무런 공유락을 걸지 않는다
  - 배타락은 갱신 손실 문제 때문에 걸어야 한다.
- 다른 트랜잭션에 공유락과 배타락이 걸린 데이터를 대기하지 않고 읽는다.
  - 다른 트랜잭션이 COMMIT하지 않은 데이터도 읽을 수 있다.
  - 오손 페이지의 데이터를 읽게 된다.
- SELECT 질의의 대상이 되는 테이블에 대해서 락을 설정하지 않은 것

| 모드   | READ UNCOMMITTED                                                                                                     |
| ------ | -------------------------------------------------------------------------------------------------------------------- |
| LOCK   | SELECT 문 - 공유락 걸지 않음<br />UPDATE문 - 배타락 설정함<br />다른 트랜잭션의 공유락과 배타락이 걸린 데이터를 읽음 |
| SQL 문 | SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED                                                                     |
| 문제점 | 오손 읽기, 반복 불가능 읽기, 유령데이터 읽기                                                                         |

#### READ COMMITTED(Level=1)

- 오손 페이지 참조를 피하고자 자신의 데이터를 읽는 동안 공유락을 걸지만, 트랜잭션이 끝나기 전에도 해지할 수 있다.

| 모드   | READ COMMITTED                                                                                                                             |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------ |
| LOCK   | SELECT 문 - 공유락을 걸고 끝나면 바로 해지함<br />UPDATE 문 - 배타락 설정함<br />다른 트랜잭션이 설정한 공유락은 읽지만 배타락은 읽지 못함 |
| SQL 문 | SET TRANSACTION ISOLATION LEVEL READ COMMITTED                                                                                             |
| 문제점 | 반복불가능 읽기, 유령데이터 읽기                                                                                                           |

#### REPEATABLE READ(Level=2)

- 자신의 데이터에 설정된 공유락과 배타락을 트랜잭션이 종료될 때까지 유지 ➡️ 다른 트랜잭션이 자신의 데이터를 갱신할 수 없도록 한다.
- 데이터의 **동시성이 낮아** 특별한 상황이 아니라면 사용하지 않는 것이 좋다.

| 모드   | REPEATABLE READ                                                                                                                                  |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| LOCK   | SELECT 문 - 공유락을 걸고 트랜잭션을 끝까지 유지함<br />UPDATE 문 - 배타락 설정함<br />다른 트랜잭션이 설정한 공유락은 읽지만 배타락은 읽지 못함 |
| SQL 문 | SET TRANSACTION ISOLATION LEVEL REPEATABLE READ                                                                                                  |
| 문제점 | 유령데이터 읽기                                                                                                                                  |

#### SERIALIZABLE(Level=3)

- 고립수준이 가장 높은 명령어
- 실행 중인 트랜잭션은 다른 트랜잭션으로부터 완벽하게 분리된다.
- 제한이 가장 심하므로 트랜잭션의 동시 수행성도 가장 낮다
- SELECT 질의의 대상이 되는 테이블에 미리 배타락을 설정한 것과 같은 효과를 낸다.

| 모드   | SERIALIZABLE                                                                                                                                                                                                        |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| LOCK   | SELECT 문 - 공유락을 걸고 트랜잭션을 끝까지 유지함<br />UPDATE 문 - 배타락 설정함<br />다른 트랜잭션이 설정한 공유락은 읽지만 배타락은 읽지 못함<br />인덱스에 공유락을 설정하여 다른 트랜잭션의 INSERT 문이 금지됨 |
| SQL 문 | SET TRANSACTION ISOLATION LEVEL SERIALIZABLE                                                                                                                                                                        |
| 문제점 | 없음                                                                                                                                                                                                                |
