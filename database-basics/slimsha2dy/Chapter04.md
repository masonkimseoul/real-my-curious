## 정규화

- 정규화의 기본 목표는 테이블 간의 중복된 데이터를 허용하지 않는 것
→ 무결성을 유지할 수 있고 DB의 저장 용량도 줄일 수 있음
- 제 1 정규화
    - 테이블의 컬럼이 원자값, 즉 하나의 값을 갖도록 분해하는 것
    - 한 attirbute에 여러 값을 갖고 있지 않도록
- 제 2 정규화
    - 제 1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 분해하는 것
    - 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속이 되도록 하는 것(= 부분적 종속성을 제거하는 것)
    - 완전 함수 종속: 기본키의 부분집합이 결정자가 되어선 안된다는 것
        - 즉 기본키의 부분 집합이 어떤 값을 항상 결정하는 상황
        - (학생번호, 강좌이름) → (성적), (강좌이름) → (강의실)
- 제 3 정규화
    - 제 2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 분해하는 것
        - 이행적 종속: A → B, B → C가 성립할 때 A → C가 성립하는 것
        - A가 B를 결정하고 B가 C를 결정하는 상황
- BCNF 정규화
    - 제 3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것

---

## 트랜잭션

- 정의
    - 단일한 논리적인 작업 단위
    - 논리적인 이유로 여러 SQL 문들을 단일 작업으로 묶어서 나눠질 수 없게 만든 것
    - 일부만 성공해서 DB에 반영되는 일은 일어나지 않는다
- 사용법
    
    ```sql
    // 계좌이체 트랜잭션 예시
    START TRANSACTION  // 트랜잭션을 시작한다
    UPDATE account SET balance = balance - 200000 WHERE id = 'J';
    UPDATE account SET balance = balance + 200000 WHERE id = 'H';
    COMMIT;  // 지금까지 작업한 내용을 DB에 영구적으로 저장하라. 트랜잭션을 종료한다.
    
    ROLLBACK;  // 지금까지 작업들을 모두 취소하고 트랜잭션 이전 상태로 되돌린다. 트랜잭션을 종료한다.
    ```
    
- **AUTOCOMMIT**
    - 각각의 SQL 문을 자동으로 트랜잭션 처리 해주는 개념
    - SQL 문이 성공적으로 실행하면 자동으로 commit 함
    - 실행 중에 문제가 생기면 알아서 rollback
    - MySQL에서는 default로 autocommit이 enabled 되어 있음
    - 다른 DBMS에서도 대부분 같은 기능을 제공한다
    
    ```sql
    SELECT @@AUTOCOMMIT; // AUTOCOMMIT이 현재 활성화되어있는지 아닌지
    										 // 1이면 활성화되어있다는 뜻. TRUe
    insert into account values ('W', 100000);  // insert를 실행하면 자동으로 commit
    
    SET autocommit=0;  // 비활성화
    DELETE FROM account WHERE balance <= 100000
    ROLLBACK;  // 삭제된 계좌를 복원할 수 있음
    ```
    
    - `START TRANSACTION`  실행과 동시에 autocommit은 비활성화됨
    - `COMMIT` , `ROLLBACK` 과 함께 트랜잭션이 종료되면 원래 autocommit 상태로 돌아감

### ACID

- **Atomicity**: 원자성
    - 트랜잭션은 논리적으로 쪼개질 수 없는 작업 단위이므로 내부의 SQL 문들이 모두 성공해야 함
    - 중간에 실패하면 지금까지의 작업을 모두 취소하며 아무 일도 없었던 것처럼
    - DBMS가 하는 일: commit/rollback 시 DB에 저장/되돌리는 것
    - 개발자가 하는 일: 언제 commit/rollback할지
- **Consistency**: 일관성
    - 데이터베이스의 일관성을 유지하는 것
    - 트랜잭션은 DB 상태를 consistent 상태에서 또 다른 consistent 상태로 바꿔주어야 함
    - constraints, trigger 등을 통해 정의된 rules를 트랜잭션이 위반하면 롤백해야 함
    - 트랜잭션이 DB rule을 위반했는지는 DBMS가 commit 전에 확인하고 알려줌
    - 그 외 application 관점에서 트랜잭션이 consistent하게 동작하는지는 개발자가 챙겨야 함
- **Isolation**: 격리
    - 여러 트랜잭션들이 동시에 실행될 때도 혼자 실행되는 것처럼 동작하게 만듬
    - DBMS는 여러 종류의 isolation level을 제공
        - 높을 수록 보다 엄격하게 격리시켜서 다른 트랜잭션으로부터 영향을 덜 받게 하지만, 동시성이 떨어지므로 DB server의 perfomance는 줄어듬
    - 개발자는 이 level 중 어떤 level로 트랜잭션을 동작시킬지 설정할 수 있음
    - concurrency control의 주된 목표가 isolation임
- **Durability**: 영존성
    - commit된 트랜잭션은 DB에 영구적으로 저장됨
    - DB system에 문제(power fail or DB crash)가 생겨도 commit된 트랜잭션은 DB에 남아 있는다
    - “영구적으로 저장한다”라고 할 때는 “비휘발성 메모리에 저장함”을 의미
    - 이는 DBMS가 보장함. 개발자가 따로 신경 쓰지 않고 믿고 씀

### Isolation Lebel

- **dirty read**
    - commit되지 않은 변화를 읽음
    
    ![스크린샷 2024-08-07 오후 6.31.53.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5abfc1c1-9cb1-494f-bd78-23fcb8cd8146/898aecd7-b409-4a38-9147-0697cac8b04b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-08-07_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.31.53.png)
    
    - 70은 유효한 값이 아닌데 트랜잭션1은 이 값으로 결과를 내게 됨
- **non-repeatable read**
    - 같은 데이터의 값이 달라짐(Fuzzy read라고도 함)
    
    ![스크린샷 2024-08-07 오후 6.34.07.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5abfc1c1-9cb1-494f-bd78-23fcb8cd8146/9dad0001-8272-4bf3-9134-32e1559dd7f2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-08-07_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.34.07.png)
    
    - 같은 트랜잭션에서 한 값을 두 번 읽었는데 갑자기 값이 바뀜
    - 여러 트랜잭션이 동작하고 있어도 각각은 혼자 실행되는 것처럼 동작해야 한다를 위반
- **phantom read**
    - 없던 데이터가 생김
    
    ![스크린샷 2024-08-07 오후 6.37.47.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5abfc1c1-9cb1-494f-bd78-23fcb8cd8146/6fd64514-7277-4db2-9778-0f10f3741aea/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-08-07_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.37.47.png)
    
    - 동일한 것을 두 번 읽었는데 결과가 다름
- 이 현상들을 모두 발생하지 않게 만들 수 있지만 그러면 제약 사항이 많아져서 동시 처리 가능한 트랜잭션 수가 줄어들어 결국 DB의 전체 처리량이 하락(성능 저하)
→ 그러면 허용하는 정도에 따라 몇 가지 레벨을 만들어서 사용자가 선택할 수 있게 하자!
- 이게 isolation level이다

![스크린샷 2024-08-07 오후 6.41.31.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5abfc1c1-9cb1-494f-bd78-23fcb8cd8146/2714677c-9de8-47b5-bb5d-93d5842e539d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-08-07_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.41.31.png)

- 근데 Serializable은 위 세 가지 뿐 아니라 그 어떤 이상 현상도 일어나지 않는다
- 이 레벨을 통해 처리량 ↔ 일관성 사이에서 어느 정도 trade를 할 수 있음

---

## 락

> 트랜잭션 처리의 순차성을 보장하기 위한 방법
> 
- **공유락(Shared Lock, Read Lock)**
    - 데이터를 읽을 때 사용되는 Lock
    - 공유락끼리는 접근 가능하지만 배타락은 접근 불가능
- **배타락(Exclusive Lock, Write Lock)**
    - 데이터를 변경할 때 사용되는 Lock
    - Lock이 해제될 때까지 다른 트랜잭션은 리소스에 접근할 수 없음
- **블로킹**
    - Lock 간(배타-배타, 배타-공유)의 경합이 발생하여 특정 트랜잭션이 작업을 진행하지 못하고 멈춰선 상태
    - 해소하기 위해서는 이전의 트랜잭션이 완료되어야 함
    - 성능에 악영향을 미친다 → 최소화하면 좋을듯
    - 어떻게?
        - 트랜잭션의 길이를 길게 하면 경합의 확률이 오름
        - 설계할 때 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록
        - 격리성 수준을 불필요하게 상향 조정하지 않는다
        - 쿼리를 오랜시간 잡아두지 않도록 적절한 튜닝을 진행
- **데드락**
    - 두 트랜잭션이 각각 락을 설정하고 서로의 락에 접근하여 값을 얻어오려고 해서 영원히 둘 다 처리되지 않는 상태
    - DBMS에서는 둘 중 한 트랜잭션에 에러를 발생시킴으로써 문제를 해결함
    - 가능성을 줄이기 위해 접근 순서를 동일하게 하는 것이 중요하다
- **낙관적 락 비관적 락**
    - 비관적 락: 실제로 락 걸기
    - 낙관적 락: 실제로 락을 걸지 않고, 수정 시 이 값을 수정했다고 명시하여 다른 사람이 수정할 수 없게 하는 것
        - a와 b가 버전 1을 읽음 → a가 수정을 하면 버전을 2로 갱신 → b가 수정을 하고 확인했는데 이전에 읽은 버전 1과 다름 → b는 실패
